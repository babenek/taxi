/******************************************************************************/
/***          Generated by IBExpert 2008.09.14 12.06.2010 11:08:39          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

CREATE DATABASE 'D:\taxi\TAXI.FDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION ADDDAY
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDDAY2
    TIMESTAMP,
    INTEGER,
    TIMESTAMP
    RETURNS PARAMETER 3
    ENTRY_POINT 'addDay2' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDHOUR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addHour' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMILLISECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMINUTE
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMONTH
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDSECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDWEEK
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDYEAR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addYear' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DIV
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_div' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION DNULLIF
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DNVL
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DOW
    TIMESTAMP,
    VARCHAR(15)
    RETURNS PARAMETER 2
    ENTRY_POINT 'DOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DPOWER
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'power' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION GETEXACTTIMESTAMP
    TIMESTAMP
    RETURNS PARAMETER 1
    ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION GETEXACTTIMESTAMPUTC
    TIMESTAMP
    RETURNS PARAMETER 1
    ENTRY_POINT 'getExactTimestampUTC' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NULLIF
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS NUMERIC(18,4) BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NVL
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS NUMERIC(18,0) BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64ROUND
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64TRUNCATE
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INULLIF
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INVL
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ISLEAPYEAR
    TIMESTAMP
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION LTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SDOW
    TIMESTAMP,
    VARCHAR(5)
    RETURNS PARAMETER 2
    ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SNULLIF
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SNVL
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SRIGHT
    VARCHAR(100) BY DESCRIPTOR,
    SMALLINT,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'right' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRING2BLOB
    VARCHAR(300) BY DESCRIPTOR,
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(32767)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTRLEN
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TRUNCATE
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';




/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GENERATOR_ID;
SET GENERATOR GENERATOR_ID TO 1006;

CREATE GENERATOR GEN_UNIQA;
SET GENERATOR GEN_UNIQA TO 1913;

CREATE GENERATOR GEN_UNIQC;
SET GENERATOR GEN_UNIQC TO 900;

CREATE GENERATOR GEN_UNIQE;
SET GENERATOR GEN_UNIQE TO 4;

CREATE GENERATOR GEN_UNIQL;
SET GENERATOR GEN_UNIQL TO 1222890;

CREATE GENERATOR GEN_UNIQO;
SET GENERATOR GEN_UNIQO TO 1244192;

CREATE GENERATOR GEN_UNIQR;
SET GENERATOR GEN_UNIQR TO 47475;

CREATE GENERATOR GEN_UNIQS;
SET GENERATOR GEN_UNIQS TO 3038;

CREATE GENERATOR GEN_UNIQT;
SET GENERATOR GEN_UNIQT TO 227;

CREATE GENERATOR GEN_UNIQV;
SET GENERATOR GEN_UNIQV TO 10;

CREATE GENERATOR GEN_UNIQW;
SET GENERATOR GEN_UNIQW TO 227;



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE CLIENT_INSERT (
    VI_NAME VARCHAR(64),
    VI_INFO VARCHAR(64),
    VI_ADRESS VARCHAR(64),
    VI_PHONE VARCHAR(64))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE EXCHANGE_GET
RETURNS (
    VO_UNIQE INTEGER,
    VO_RATE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE EXCHANGE_SET (
    VI_RATE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ITOG (
    VI_SMN_START INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE LOCATION_CHECK (
    VI_TIMEOUT_11 TIMESTAMP,
    VI_TIMEOUT_9 TIMESTAMP,
    VI_TIMEOUT_7 TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE LOCATION_MARK (
    VI_PREV_LOCATIONS INTEGER,
    VI_THM_RESSORT SMALLINT,
    VI_SMN_START INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE LOCATION_ROLLBACK (
    VI_SMENA INTEGER,
    VI_UNIQL INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE LOCATION_START (
    VI_THEME SMALLINT,
    VI_LOCATION SMALLINT,
    VI_LOC_TYPE SMALLINT,
    VI_THM_RESSORT SMALLINT,
    VI_SMN_START INTEGER,
    VI_PREV_LOCATIONS INTEGER)
RETURNS (
    VO_UNIQL INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE LOCATION_STOP (
    VI_UNIQL INTEGER,
    VI_SMN_STOP INTEGER)
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE LOCATION_UNMARK (
    VI_THEME INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE LOCATION_UPDATE (
    VI_UNIQL INTEGER,
    VI_THM_RESSORT SMALLINT,
    VI_LOC_TYPE SMALLINT)
RETURNS (
    VO_UPDATE_COUNT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ORDER_DELETE (
    VI_UNIQO INTEGER,
    VI_SMN_STOP INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ORDER_START (
    VI_THEME SMALLINT,
    VI_LOCATIONS INTEGER,
    VI_TYPE SMALLINT,
    VI_SMN_START INTEGER,
    VI_DEPARTURE VARCHAR(250),
    VI_DESTINATION VARCHAR(250),
    VI_STATE SMALLINT,
    VI_TIME_START TIMESTAMP,
    VI_COST DOUBLE PRECISION,
    VI_PHONE VARCHAR(64),
    VI_CLIENT INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE ORDER_STOP (
    VI_SMN_STOP INTEGER,
    VI_TIME_STOP TIMESTAMP,
    VI_KEY_LOCATIONS INTEGER)
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ORDER_UPDATE (
    VI_UNIQO INTEGER,
    VI_ORD_TYPE SMALLINT,
    VI_STATE SMALLINT,
    VI_DURATION TIME,
    VI_DISTANCE INTEGER,
    VI_COST DOUBLE PRECISION,
    VI_DEPARTURE VARCHAR(250),
    VI_DESTINATION VARCHAR(250),
    VI_TIME_START TIMESTAMP,
    VI_TIME_STOP TIMESTAMP,
    VI_SMN_STOP INTEGER,
    VI_CLIENT INTEGER,
    VI_PHONE VARCHAR(64))
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE REPORT_CREATE (
    VI_DATE_START DATE,
    VI_DATE_STOP DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REPORT_ITOG (
    VI_WEEK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REPORT_RECALC (
    VI_WEEK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REPORT_THM_INFO (
    VI_WEEK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE REPORT_UPDATE (
    VI_WEEK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE RESSORT_DAY
RETURNS (
    VO_RESSORT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RESSORT_NIGHT
RETURNS (
    VO_RESSORT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SMENA_ACTION (
    VI_UNIQS INTEGER,
    VI_SMN_ACTION SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SMENA_CHECK (
    VI_UNIQS INTEGER)
RETURNS (
    VO_SMN_STATE SMALLINT,
    VO_SMN_WEEKEND SMALLINT,
    VO_SMN_ACTION SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SMENA_ITOG (
    VI_UNIQS INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SMENA_REPNO (
    VI_UNIQS INTEGER)
RETURNS (
    VO_ORDERS INTEGER,
    VO_HOURS INTEGER,
    VO_ORD_COST NUMERIC(8,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SMENA_REPORT (
    START_DATE DATE,
    STOP_DATE DATE)
RETURNS (
    VO_UNIQS INTEGER,
    VO_USR_LIST VARCHAR(250),
    VO_SMN_DATE DATE,
    VO_DAY_NIGHT VARCHAR(5),
    VO_ORDERS INTEGER,
    VO_ORD_COST NUMERIC(8,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SMENA_START (
    VI_DAY_NIGHT SMALLINT,
    VI_DATE DATE,
    VI_USR_LIST VARCHAR(250))
RETURNS (
    VO_UNIQS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SMENA_STOP (
    VI_UNIQS INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE SMENA_WEEKEND (
    VI_UNIQS INTEGER,
    VI_SMN_WEEKEND SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE THEME_ARCHIVE (
    VI_THEME SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE THEME_MARKER (
    VI_THEME SMALLINT,
    VI_MARKER VARCHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE UPDATE_DICOUNT
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE VEHICLE_ADD (
    VI_THEME SMALLINT,
    VI_MODEL VARCHAR(32),
    VI_NUMBER VARCHAR(32),
    VI_COST NUMERIC(8,2),
    VI_DURATION SMALLINT,
    VI_RENTAL NUMERIC(8,2),
    VI_INFO VARCHAR(256))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE VEHICLE_PAY (
    VI_UNIQV INTEGER,
    VI_ARN_ACTION SMALLINT,
    VI_ARN_DATE DATE,
    VI_SMENA INTEGER,
    VI_MONEY NUMERIC(8,2),
    VI_INFO VARCHAR(252))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE VEHICLE_ROLLBACK (
    VI_UNIQA INTEGER)
AS
BEGIN
  EXIT;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ARENDA (
    UNIQA           INTEGER NOT NULL,
    PREV_UNIQA      SMALLINT,
    ARN_STATE       SMALLINT,
    KEY_UNIQV       INTEGER,
    KEY_THEME       SMALLINT,
    ARN_DATE        DATE,
    KEY_SMN_START   INTEGER,
    KEY_SMN_STOP    INTEGER,
    KEY_ARN_ACTION  SMALLINT,
    TIME_START      TIMESTAMP,
    TIME_STOP       TIMESTAMP,
    MONEY           NUMERIC(8,2),
    CURRENCY        NUMERIC(8,2),
    BALANCE         NUMERIC(8,2),
    KEY_EXCHANGE    INTEGER,
    INFO            VARCHAR(252)
);

CREATE TABLE CFG (
    "MOD"  VARCHAR(16),
    PAR    VARCHAR(16),
    VAL    VARCHAR(16)
);

CREATE TABLE CLIENTS (
    UNIQC         INTEGER NOT NULL,
    CLT_NAME      VARCHAR(64),
    CLT_INFO      VARCHAR(64),
    CLT_ADRESS    VARCHAR(64),
    CLT_PHONE     VARCHAR(64),
    CLT_TYPE      SMALLINT,
    CLT_COUNTER   SMALLINT,
    CLT_DISCOUNT  SMALLINT
);

CREATE TABLE COLORS (
    FREQ     SMALLINT NOT NULL,
    STATE    SMALLINT NOT NULL,
    CAPTION  VARCHAR(16),
    HINT     VARCHAR(64),
    LABEL_R  SMALLINT NOT NULL,
    LABEL_G  SMALLINT NOT NULL,
    LABEL_B  SMALLINT NOT NULL,
    FONT_R   SMALLINT NOT NULL,
    FONT_G   SMALLINT NOT NULL,
    FONT_B   SMALLINT NOT NULL
);

CREATE TABLE EXCHANGE (
    UNIQE       INTEGER NOT NULL,
    RATE        DOUBLE PRECISION,
    TIME_START  TIMESTAMP,
    TIME_STOP   TIMESTAMP,
    STATE       SMALLINT
);

CREATE TABLE LOCATIONS (
    UNIQL           INTEGER NOT NULL,
    PREV_LOCATIONS  INTEGER,
    LOC_STATE       SMALLINT,
    KEY_THEME       SMALLINT,
    KEY_LOCATION    SMALLINT,
    KEY_LOC_TYPE    SMALLINT,
    THM_RESSORT     SMALLINT,
    TIME_START      TIMESTAMP,
    TIME_STOP       TIMESTAMP,
    KEY_SMN_START   INTEGER,
    KEY_SMN_STOP    INTEGER
);

CREATE TABLE ORDERS (
    UNIQO            INTEGER NOT NULL,
    KEY_THEME        SMALLINT NOT NULL,
    KEY_LOCATIONS    INTEGER NOT NULL,
    KEY_ORD_TYPE     SMALLINT NOT NULL,
    KEY_CLIENT       INTEGER,
    ORD_STATE        SMALLINT,
    ORD_DURATION     TIME,
    ORD_DISTANCE     INTEGER,
    ORD_COST         DOUBLE PRECISION,
    ORD_HOURS        INTEGER,
    ORD_ITOG         DOUBLE PRECISION,
    KEY_SMN_START    INTEGER,
    KEY_SMN_STOP     INTEGER,
    TIME_START       TIMESTAMP,
    TIME_STOP        TIMESTAMP,
    ORD_DESTINATION  VARCHAR(252),
    ORD_DEPARTURE    VARCHAR(252),
    ORD_PHONE        VARCHAR(64),
    ADM_ITOG         DOUBLE PRECISION
);

CREATE TABLE REPORTS (
    UNIQR        INTEGER NOT NULL,
    KEY_THEME    SMALLINT,
    KEY_WEEK     INTEGER,
    REP_ORDERS   NUMERIC(8,2),
    REP_REKLAMA  NUMERIC(8,2),
    REP_MEDIK    NUMERIC(8,2),
    REP_DOLG     NUMERIC(8,2),
    REP_KWART    NUMERIC(8,2),
    REP_ITOG     NUMERIC(8,2),
    REP_OT4ET    NUMERIC(8,2),
    REP_OSTATOK  NUMERIC(8,2),
    REP_CORRECT  NUMERIC(8,2)
);

CREATE TABLE S_ARN_ACTION (
    COD_ARN_ACTION   SMALLINT NOT NULL,
    NAME_ARN_ACTION  VARCHAR(32),
    STATE_ARENDA     SMALLINT,
    MUX_ACCOUNT      NUMERIC(8,2),
    MUX_BALANCE      NUMERIC(8,2)
);

CREATE TABLE S_LOC_TYPE (
    COD_LOC_TYPE   SMALLINT NOT NULL,
    NAME_LOC_TYPE  VARCHAR(32)
);

CREATE TABLE S_LOCATION (
    COD_LOCATION     SMALLINT NOT NULL,
    NAME_LOCATION    VARCHAR(32),
    POS_TOP          SMALLINT,
    POS_LEFT         SMALLINT,
    HEIGHT           SMALLINT,
    WIDTH            SMALLINT,
    S_LOCATION_TYPE  SMALLINT
);

CREATE TABLE S_ORD_MOD (
    ID             INTEGER NOT NULL,
    KEY_ORD_TYPE   SMALLINT NOT NULL,
    THM_FREQ       SMALLINT,
    COST_ORDER     DOUBLE PRECISION,
    COST_HNEXT     DOUBLE PRECISION,
    COST_DURATION  DOUBLE PRECISION,
    COST_DISTANCE  DOUBLE PRECISION,
    COST_MUX       DOUBLE PRECISION
);

CREATE TABLE S_ORD_TYPE (
    COD_ORD_TYPE   SMALLINT NOT NULL,
    NAME_ORD_TYPE  VARCHAR(32),
    ORD_TYPE       SMALLINT,
    COST_ORDER     DOUBLE PRECISION,
    COST_HNEXT     DOUBLE PRECISION,
    COST_DURATION  DOUBLE PRECISION,
    COST_DISTANCE  DOUBLE PRECISION,
    COST_MUX       DOUBLE PRECISION
);

CREATE TABLE S_THEME (
    COD_THEME    SMALLINT NOT NULL,
    THM_MODEL    VARCHAR(32),
    THM_COLOR    VARCHAR(32),
    THM_NUMBER   VARCHAR(32),
    THM_INFO     VARCHAR(32),
    THM_FREQ     SMALLINT,
    THM_BRIGADE  VARCHAR(1),
    THM_PREFIX   VARCHAR(1),
    THM_SUFFIX   VARCHAR(1),
    THM_TYPE     SMALLINT,
    THM_MARKER   VARCHAR(1)
);

CREATE TABLE S_USER (
    COD_USER   SMALLINT NOT NULL,
    NAME_USER  VARCHAR(32)
);

CREATE TABLE SMENA (
    UNIQS           INTEGER NOT NULL,
    SMN_TIME_START  TIMESTAMP,
    SMN_TIME_STOP   TIMESTAMP,
    SMN_STATE       SMALLINT,
    SMN_WEEKEND     SMALLINT,
    SMN_ACTION      SMALLINT,
    SMN_DATE        DATE,
    SMN_DAY_NIGHT   SMALLINT,
    USR_LIST        VARCHAR(250),
    ORD_COUNT       COMPUTED BY ((select count(o2.uniqo)
from orders o2, s_ord_type so2
where  o2.KEY_SMN_START = smena.uniqs
        and O2.ORD_STATE in (1,3)
        and o2.key_ord_type = so2.cod_ord_type
        and so2.ORD_TYPE in (1,3)))
);

CREATE TABLE THEMES (
    UNIQT       INTEGER NOT NULL,
    KEY_THEME   SMALLINT NOT NULL,
    THM_MODEL   VARCHAR(32) CHARACTER SET NONE,
    THM_COLOR   VARCHAR(32) CHARACTER SET NONE,
    THM_NUMBER  VARCHAR(32),
    THM_INFO    VARCHAR(32),
    REP_DOLG    NUMERIC(8,2),
    TIME_START  TIMESTAMP
);

CREATE TABLE VEHICLES (
    UNIQV       INTEGER NOT NULL,
    KEY_THEME   SMALLINT,
    MODEL       VARCHAR(32),
    NUMBER      VARCHAR(32),
    INFO        VARCHAR(256),
    COST        NUMERIC(8,2),
    CURRENCY    NUMERIC(8,2),
    ACCOUNT     NUMERIC(8,2),
    DURATION    SMALLINT,
    RENTAL      NUMERIC(8,2),
    TIME_START  TIMESTAMP,
    TIME_STOP   TIMESTAMP,
    VHC_STATE   SMALLINT
);

CREATE TABLE WEEKS (
    UNIQW          INTEGER NOT NULL,
    DATE_START     DATE,
    DATE_STOP      DATE,
    KEY_PREV_WEEK  INTEGER,
    DATE_CREATE    TIMESTAMP,
    DATE_UPDATE    TIMESTAMP,
    DATE_CLOSE     TIMESTAMP,
    WKS_STATE      SMALLINT DEFAULT 0
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: V_LOCATIONS */
CREATE VIEW V_LOCATIONS(
    UNIQL,
    PREV_LOCATIONS,
    KEY_THEME,
    THEME_LABEL,
    THEME_INFO,
    KEY_LOCATION,
    KEY_LOC_TYPE,
    LOC_STATE,
    THM_RESSORT,
    TIME_START)
AS
SELECT
    uniql,
    prev_locations,
    KEY_THEME,
    coalesce(THM_MARKER,'') || coalesce(THM_PREFIX,'') || COD_THEME || coalesce(THM_SUFFIX,''),
    coalesce(THM_INFO,''),
    KEY_LOCATION,
    key_loc_type,
    LOC_STATE,
    thm_ressort,
    time_start
FROM
   LOCATIONS, s_theme
WHERE
    (loc_state = 0 or loc_state = 4)
    and key_theme > 0
    and locations.key_theme=s_theme.cod_theme

order by THM_RESSORT,uniql
;



/* View: V_ORDERS_DELAY */
CREATE VIEW V_ORDERS_DELAY(
    UNIQO,
    KEY_THEME,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    KEY_SMN_START,
    TIME_START,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE)
AS
select
    UNIQO,
    KEY_THEME,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    KEY_SMN_START,
    TIME_START,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE
from orders
where ord_state = 4
;



/* View: V_ORDERS_ONLINE */
CREATE VIEW V_ORDERS_ONLINE(
    UNIQO,
    KEY_THEME,
    KEY_LOCATIONS,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    ORD_STATE,
    ORD_DURATION,
    ORD_DISTANCE,
    ORD_COST,
    ORD_HOURS,
    ORD_ITOG,
    KEY_SMN_START,
    KEY_SMN_STOP,
    TIME_START,
    TIME_STOP,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE)
AS
select
    UNIQO,
    KEY_THEME,
    KEY_LOCATIONS,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    ORD_STATE,
    ORD_DURATION,
    ORD_DISTANCE,
    ORD_COST,
    ORD_HOURS,
    ORD_ITOG,
    KEY_SMN_START,
    KEY_SMN_STOP,
    TIME_START,
    TIME_STOP,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE
from orders
where ord_state = 0
;



/* View: V_ORDERS_REZERV */
CREATE VIEW V_ORDERS_REZERV(
    UNIQO,
    KEY_THEME,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    KEY_SMN_START,
    TIME_START,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE)
AS
select
    UNIQO,
    KEY_THEME,
    KEY_ORD_TYPE,
    KEY_CLIENT,
    KEY_SMN_START,
    TIME_START,
    ORD_DESTINATION,
    ORD_DEPARTURE,
    ORD_PHONE
from orders
where ord_state = 6
;




/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE S_ORD_MOD ADD CONSTRAINT UNQ1_S_ORD_MOD UNIQUE (KEY_ORD_TYPE, THM_FREQ);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ARENDA ADD CONSTRAINT PK_ARENDA PRIMARY KEY (UNIQA);
ALTER TABLE CLIENTS ADD CONSTRAINT PK_CLIENTS PRIMARY KEY (UNIQC);
ALTER TABLE COLORS ADD CONSTRAINT PK_COLORS PRIMARY KEY (FREQ, STATE);
ALTER TABLE EXCHANGE ADD CONSTRAINT PK_EXCHANGE PRIMARY KEY (UNIQE);
ALTER TABLE LOCATIONS ADD CONSTRAINT PK_LOCATIONS PRIMARY KEY (UNIQL);
ALTER TABLE ORDERS ADD CONSTRAINT PK_ORDERS PRIMARY KEY (UNIQO);
ALTER TABLE REPORTS ADD CONSTRAINT PK_REPORTS PRIMARY KEY (UNIQR);
ALTER TABLE SMENA ADD CONSTRAINT PK_SMENA PRIMARY KEY (UNIQS);
ALTER TABLE S_ARN_ACTION ADD CONSTRAINT PK_S_ARN_ACTION PRIMARY KEY (COD_ARN_ACTION);
ALTER TABLE S_LOCATION ADD CONSTRAINT PK_S_LOCATION PRIMARY KEY (COD_LOCATION);
ALTER TABLE S_LOC_TYPE ADD CONSTRAINT PK_S_LOC_TYPE PRIMARY KEY (COD_LOC_TYPE);
ALTER TABLE S_ORD_MOD ADD CONSTRAINT PK_S_ORD_MOD PRIMARY KEY (ID);
ALTER TABLE S_ORD_TYPE ADD CONSTRAINT PK_S_ORD_TYPE PRIMARY KEY (COD_ORD_TYPE);
ALTER TABLE S_THEME ADD CONSTRAINT PK_S_THEME PRIMARY KEY (COD_THEME);
ALTER TABLE S_USER ADD CONSTRAINT PK_S_USER PRIMARY KEY (COD_USER);
ALTER TABLE THEMES ADD CONSTRAINT PK_THEMES PRIMARY KEY (UNIQT);
ALTER TABLE VEHICLES ADD CONSTRAINT PK_VEHICLES PRIMARY KEY (UNIQV);
ALTER TABLE WEEKS ADD CONSTRAINT PK_WEEKS PRIMARY KEY (UNIQW);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE LOCATIONS ADD CONSTRAINT FKLSMNSTART FOREIGN KEY (KEY_SMN_START) REFERENCES SMENA (UNIQS);
ALTER TABLE LOCATIONS ADD CONSTRAINT FKLSMNSTOP FOREIGN KEY (KEY_SMN_STOP) REFERENCES SMENA (UNIQS);
ALTER TABLE LOCATIONS ADD CONSTRAINT FKLTHEME FOREIGN KEY (KEY_THEME) REFERENCES S_THEME (COD_THEME);
ALTER TABLE ORDERS ADD CONSTRAINT FKOCLIENTS FOREIGN KEY (KEY_CLIENT) REFERENCES CLIENTS (UNIQC);
ALTER TABLE ORDERS ADD CONSTRAINT FKORDTYPE FOREIGN KEY (KEY_ORD_TYPE) REFERENCES S_ORD_TYPE (COD_ORD_TYPE);
ALTER TABLE ORDERS ADD CONSTRAINT FKOSMNSTART FOREIGN KEY (KEY_SMN_START) REFERENCES SMENA (UNIQS);
ALTER TABLE ORDERS ADD CONSTRAINT FKOSMNSTOP FOREIGN KEY (KEY_SMN_STOP) REFERENCES SMENA (UNIQS);
ALTER TABLE ORDERS ADD CONSTRAINT FKOTHEME FOREIGN KEY (KEY_THEME) REFERENCES S_THEME (COD_THEME);
ALTER TABLE REPORTS ADD CONSTRAINT FKRTHEME FOREIGN KEY (KEY_THEME) REFERENCES S_THEME (COD_THEME);
ALTER TABLE REPORTS ADD CONSTRAINT FKRWEEK FOREIGN KEY (KEY_WEEK) REFERENCES WEEKS (UNIQW)
  USING INDEX FK_REPORTS_1;
ALTER TABLE S_ORD_MOD ADD CONSTRAINT FK_S_ORD_MOD_1 FOREIGN KEY (KEY_ORD_TYPE) REFERENCES S_ORD_TYPE (COD_ORD_TYPE);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX INDEX_LOC_STATE ON LOCATIONS (LOC_STATE);
CREATE INDEX INDEX_ORD_LOCATIONS ON ORDERS (KEY_LOCATIONS);
CREATE INDEX INDEX_ORD_STATE ON ORDERS (ORD_STATE);
CREATE INDEX SMENA_IDX_TIME ON SMENA (SMN_DATE);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: LOCATIONS_AIUD0 */
CREATE TRIGGER LOCATIONS_AIUD0 FOR LOCATIONS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
   if (new.loc_state = 0 or new.key_smn_stop = 0 ) then
      POST_EVENT 'LOC_REFRESH';
end
^

/* Trigger: ORDERS_AIUD0 */
CREATE TRIGGER ORDERS_AIUD0 FOR ORDERS
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
   if (new.ord_state = 4 or old.ord_state = 4) then
      POST_EVENT 'ORD_REFRESH_DELAY';
   else if (new.ord_state = 0 or old.ord_state = 0) then
      POST_EVENT 'ORD_REFRESH_ONLINE';
   else if (new.ord_state = 6 or old.ord_state = 6) then
      POST_EVENT 'ORD_REFRESH_REZERV';
end
^

/* Trigger: ORDERS_BIU0 */
CREATE TRIGGER ORDERS_BIU0 FOR ORDERS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
declare variable tmp_itog numeric(8,2);
declare variable COST_ORDER double precision;
declare variable COST_DURATION double precision;
declare variable COST_DISTANCE double precision;
declare variable COST_HNEXT double precision;
declare variable COST_MUX double precision;
declare variable MOD_ORDER double precision;
declare variable MOD_DURATION double precision;
declare variable MOD_DISTANCE double precision;
declare variable MOD_HNEXT double precision;
declare variable MOD_MUX double precision;
declare variable HOURS double precision;
declare variable TMP_COUNTER integer;
begin
--
    if (new.ord_state = 1 or new.ord_state = 3) then begin
      select so.cost_order, so.cost_duration, so.cost_distance, so.cost_hnext, so.cost_mux
      from s_ord_type so
      where so.cod_ord_type = new.key_ord_type
      into :COST_ORDER, :COST_DURATION, :COST_DISTANCE, :COST_HNEXT, :COST_MUX;

      select sm.cost_order, sm.cost_duration, sm.cost_distance, sm.cost_hnext, sm.cost_mux
      from s_ord_mod sm, s_theme st
      where sm.key_ord_type = new.key_ord_type and st.cod_theme = new.key_theme and sm.thm_freq = st.thm_freq
      into :MOD_ORDER, :MOD_DURATION, :MOD_DISTANCE, :MOD_HNEXT, :MOD_MUX;
      
      if (mod_order is not null) then cost_order = mod_order;
      if (mod_duration is not null) then cost_duration = mod_duration;
      if (mod_distance is not null) then cost_distance = mod_distance;
      if (mod_hnext is not null) then cost_hnext = mod_hnext;
      if (mod_mux is not null) then cost_mux = mod_mux;

--временна€ мера, чтобы заставить выходить в ночь
      if (extract(hour from new.time_start) <6) then begin
        if (new.ord_departure ='_—¬≈–’„ј—ј_') then cost_order = 3.5;
        if (new.key_ord_type = 9) then cost_hnext = 3.5; -- три п€тьдес€т!!! за час
        end

      TMP_ITOG = 0;
      if (COST_ORDER is not null) then
         tmp_itog = tmp_itog + cost_order;
      if (COST_MUX is not null and new.ORD_COST is not null) then
         tmp_itog = tmp_itog + cost_mux * new.ord_cost;

-- =======================сменить генератор на отчетах и обновить тарифы!!!! на поездку за счет фирмы!!!!!!!
--      else begin
--         if (COST_DURATION is not null and new.ORD_DURATION is not null) then
--            tmp_itog = tmp_itog + cost_duration * (cast(new.ord_duration as double precision)/0.000694);
--         if (COST_distance is not null and new.ORD_distance is not null) then
--            tmp_itog = tmp_itog + cost_distance * new.ord_distance;
--         end


      if (COST_HNEXT is not null and new.time_stop is not null and new.time_start is not null) then begin
         --if (new.key_ord_type = 9) then
            hours=(cast ((new.time_stop-new.time_start) as double precision )-0.00001)/cast (0.041667 as double precision);
         --else
         -- hours=(cast ((new.time_stop-new.time_start)as double precision)-0.010417)/cast (0.041667 as double precision);
         TMP_COUNTER=0;
         while (hours>1) do begin
            tmp_counter=tmp_counter+1;
            hours=hours-1;
            end
         new.ord_hours = TMP_COUNTER;
         tmp_itog = tmp_itog + TMP_COUNTER * cost_hnext;
         end
      new.ord_itog = tmp_itog;

-- еще одна "временна€" мера
      if(cost_order < 0) then
        tmp_itog=tmp_itog+10;--!!!   здесь заложен тариф 10 грн
      if(cost_mux < 0) then
        tmp_itog=tmp_itog + new.ord_cost;--!!! вернем обратно стоимость
      new.adm_itog = tmp_itog;

      end

-- устанавливаетс€ дата завершени€ "висени€" заказа
   if (new.ord_state = 5 or new.ord_state = 7) then begin
      new.time_stop=current_timestamp;
      end
end
^

/* Trigger: REPORTS_BIU0 */
CREATE TRIGGER REPORTS_BIU0 FOR REPORTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
declare variable tmp_itog numeric(8,2);
begin
   tmp_itog = 0;

   if(new.rep_orders is not null) then
      tmp_itog = tmp_itog + new.rep_orders;
   if(new.rep_reklama is not null) then
      tmp_itog = tmp_itog + new.rep_reklama;
   if(new.rep_medik is not null) then
      tmp_itog = tmp_itog + new.rep_medik;
   if(new.rep_dolg is not null) then
      tmp_itog = tmp_itog + new.rep_dolg;
   if(new.rep_kwart is not null) then
      tmp_itog = tmp_itog + new.rep_kwart;
   if(new.rep_correct is not null) then
      tmp_itog = tmp_itog + new.rep_correct;

   if (tmp_itog = 0) then new.rep_itog = null;
   else new.rep_itog = tmp_itog;

   if (new.rep_ot4et is not null) then
      new.rep_ostatok = tmp_itog - new.rep_ot4et;
   else
      new.rep_ostatok = tmp_itog;

end
^

/* Trigger: S_THEME_AI0 */
CREATE TRIGGER S_THEME_AI0 FOR S_THEME
ACTIVE AFTER INSERT POSITION 0
AS
 declare variable var_uniqw integer;
begin

  insert into locations (uniql,
                        KEY_THEME,
                        KEY_LOCATION,
                        KEY_LOC_TYPE,
                        THM_RESSORT,
                        KEY_SMN_START,
                        PREV_LOCATIONS,
                        LOC_STATE,
                        TIME_START)
                 values (gen_id(gen_uniql,1),
                        new.cod_theme,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        (select current_timestamp from RDB$DATABASE));

    var_uniqw=0;
    select uniqw from weeks where wks_state = 0 into :var_uniqw ;

    insert into reports (uniqr,
                         key_theme,
                         key_week)
                 values (gen_id(gen_uniqr,1),
                         new.cod_theme,
                         :var_uniqw
                         );
end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE CLIENT_INSERT (
    VI_NAME VARCHAR(64),
    VI_INFO VARCHAR(64),
    VI_ADRESS VARCHAR(64),
    VI_PHONE VARCHAR(64))
AS
declare variable var_discount integer;
begin
/*
 if(vi_phone like '49____') then var_discount = 1;
 else var_discount = null;
*/
    var_discount = null;
    insert into clients (uniqc,clt_name,clt_info,clt_adress,clt_phone,CLT_COUNTER,clt_discount)
    values(gen_id(gen_uniqc,1),:vi_name,:vi_info,:vi_adress,:vi_phone,13,:var_discount);
    suspend;
end^


ALTER PROCEDURE EXCHANGE_GET
RETURNS (
    VO_UNIQE INTEGER,
    VO_RATE DOUBLE PRECISION)
AS
DECLARE VARIABLE VAR_UNIQE INTEGER;
DECLARE VARIABLE VAR_RATE DOUBLE PRECISION;
begin
    select uniqe, rate
    from exchange
    where state = 0
    into :var_uniqe, :var_rate;

    if (var_rate is null) then begin
        vo_uniqe=0;
        vo_rate = 0;
        end
    else begin
        vo_uniqe = var_uniqe;
        vo_rate = 1/var_rate;
        end

    suspend;
end^


ALTER PROCEDURE EXCHANGE_SET (
    VI_RATE DOUBLE PRECISION)
AS
begin
    update exchange
    set
        time_stop = (select current_timestamp from RDB$DATABASE)
        , state = 1
    where
        state = 0;

    if (vi_rate <> 0) then
        insert into exchange (uniqe, time_start, rate, state)
        values (gen_id(gen_uniqe, 1), (select current_timestamp from RDB$DATABASE), (1/:vi_rate), 0);
    
  suspend;
end^


ALTER PROCEDURE ITOG (
    VI_SMN_START INTEGER)
AS
DECLARE VARIABLE HOURS DOUBLE PRECISION;
DECLARE VARIABLE UNIQO INTEGER;
DECLARE VARIABLE ORD_DURATION TIME;
DECLARE VARIABLE ORD_DISTANCE INTEGER;
DECLARE VARIABLE ORD_COST NUMERIC(8,2);
DECLARE VARIABLE TIME_START TIMESTAMP;
DECLARE VARIABLE TIME_STOP TIMESTAMP;
DECLARE VARIABLE COD_ORD_TYPE SMALLINT;
DECLARE VARIABLE ORD_ITOG NUMERIC(8,2);
DECLARE VARIABLE COST_ORDER NUMERIC(8,2);
DECLARE VARIABLE COST_HNEXT NUMERIC(8,2);
DECLARE VARIABLE COST_DURATION NUMERIC(8,2);
DECLARE VARIABLE COST_DISTANCE NUMERIC(8,2);
DECLARE VARIABLE COST_MUX NUMERIC(8,2);
DECLARE VARIABLE TMP_COUNTER INTEGER;
begin
   for select so.cost_order, so.cost_duration, so.cost_distance, so.cost_hnext, so.cost_mux, so.cod_ord_type
   from s_ord_type so
   into :COST_ORDER, :COST_DURATION, :COST_DISTANCE, :COST_HNEXT, :COST_MUX, :COD_ORD_TYPE
   do begin
-----------------------------------------------------------------------------------------------
      for select UNIQO, ORD_COST, ORD_DISTANCE, ORD_DURATION, TIME_START, TIME_STOP
      from orders
      where key_smn_start = :VI_SMN_START
      and key_ord_type = :cod_ord_type
      and ord_state in (1, 3)
      into :UNIQO, :ORD_COST, :ORD_DISTANCE, :ORD_DURATION, :TIME_START, :TIME_STOP
      do begin
         ORD_ITOG = 0;

         if (COST_ORDER is not null) then
            ord_itog = ord_itog + cost_order;

         if (COST_MUX is not null and ORD_COST is not null) then
            ord_itog = ord_itog + cost_mux*ord_cost;
/*$$IBEC$$          else begin
            if (COST_DURATION is not null and ORD_DURATION is not null) then
               ord_itog = ord_itog + cost_duration*(cast(ord_duration as double precision)/0.000694);
            if (COST_distance is not null and ORD_distance is not null) then
               ord_itog = ord_itog + cost_distance*ord_distance;
            end $$IBEC$$*/

         if (COST_HNEXT is not null and time_stop is not null and time_start is not null) then begin
            if (cod_ord_type = 9) then
               hours=(cast ((time_stop-time_start) as double precision ))/cast (0.041667 as double precision);
            else
               hours=(cast ((time_stop-time_start)as double precision)-0.010417)/cast (0.041667 as double precision);
            TMP_COUNTER=0;
            while (hours>1) do begin
               tmp_counter=tmp_counter+1;
               hours=hours-1;
               end
            update orders set ord_hours = :TMP_COUNTER where uniqo = :uniqo;
            ord_itog = ord_itog + TMP_COUNTER * cost_hnext;
            end
------------------------------------------------------------------------------------------------
         update orders set ord_itog = :ORD_ITOG where uniqo = :UNIQO;
         end
------------------------------------------------------------------------------------------------
      end
   suspend;
end^


ALTER PROCEDURE LOCATION_CHECK (
    VI_TIMEOUT_11 TIMESTAMP,
    VI_TIMEOUT_9 TIMESTAMP,
    VI_TIMEOUT_7 TIMESTAMP)
AS
DECLARE VARIABLE VAR_UNIQL INTEGER;
DECLARE VARIABLE VAR_UNIQO INTEGER;
DECLARE VARIABLE VAR_THEME SMALLINT;
DECLARE VARIABLE VAR_TIME_START TIMESTAMP;
DECLARE VARIABLE VAR_TIME_STOP TIMESTAMP;
DECLARE VARIABLE VAR_SMN_START INTEGER;
DECLARE VARIABLE VAR_RESSORT SMALLINT;
DECLARE VARIABLE VAR_TMP INTEGER;
begin

   update locations
   set thm_ressort=7
   where loc_state=0 and thm_ressort in (1,4)
   and ((key_loc_type=9 and time_start < :VI_TIMEOUT_9) or (key_loc_type=11 and time_start < :VI_TIMEOUT_11));

   update locations
   set thm_ressort=8
   where loc_state=0 and thm_ressort in (2,5)
   and ((key_loc_type=9 and time_start < :VI_TIMEOUT_9) or (key_loc_type=11 and time_start < :VI_TIMEOUT_11));

   update locations
   set thm_ressort=9
   where loc_state=0 and thm_ressort in (3,6)
   and ((key_loc_type=9 and time_start < :VI_TIMEOUT_9) or (key_loc_type=11 and time_start < :VI_TIMEOUT_11));

   for select uniql, key_theme, thm_ressort, time_start, key_smn_start
   from locations
   where loc_state = 0 and key_loc_type=7 and time_start < :VI_TIMEOUT_7
   into :var_uniql, :var_theme, :var_ressort, :var_time_start, :var_smn_start do begin
-- каменты дл€ того, чтобы на своих почасовка считалась как _—¬≈–’„ј—ј_
--      select count(uniqo) from orders where key_locations = :var_uniql and key_ord_type = 9 into :var_uniqo;
--      if (var_uniqo = 0) then begin
         select vo_update_count from location_update(:var_uniql,:var_ressort,7) into :var_tmp;
         if (var_tmp <> 0) then begin
            insert into orders (uniqo, KEY_THEME, KEY_LOCATIONS, KEY_ORD_TYPE, ORD_DEPARTURE, KEY_smn_start, ORD_state, TIME_START, TIME_STOP, key_client)
            values (gen_id(gen_uniqo,1), :var_theme, :var_uniql, 1, '_—¬≈–’„ј—ј_', :var_smn_start, 3, :var_time_start, (select current_timestamp from RDB$DATABASE),0);
            update orders set time_start = (select current_timestamp from RDB$DATABASE) where key_locations = :var_uniql and ord_state  = 0;
            end
            
--         end

      end

  suspend;
end^


ALTER PROCEDURE LOCATION_MARK (
    VI_PREV_LOCATIONS INTEGER,
    VI_THM_RESSORT SMALLINT,
    VI_SMN_START INTEGER)
AS
    declare variable var_theme smallint;
    declare variable var_location smallint;
    declare variable var_loc_type smallint;
    declare variable var_thm_ressort smallint;
begin
    select
        key_theme,
        key_location,
        key_loc_type
    from
        locations
    where
        uniql = :vi_prev_locations
    into
        :var_theme,
        :var_location,
        :var_loc_type;


  insert into locations (uniql,
                        KEY_THEME,
                        KEY_LOCATION,
                        KEY_LOC_TYPE,
                        THM_RESSORT,
                        KEY_SMN_START,
                        PREV_LOCATIONS,
                        LOC_STATE,
                        TIME_START)
                 values (
                        next value for gen_uniql,
                        :var_theme,
                        :var_location,
                        :var_loc_type,
                        :vi_THM_RESSORT,
                        :VI_SMN_START,
                        :VI_PREV_LOCATIONS,
                        4,
                        (select current_timestamp from RDB$DATABASE));
  suspend;
end^


ALTER PROCEDURE LOCATION_ROLLBACK (
    VI_SMENA INTEGER,
    VI_UNIQL INTEGER)
AS
--DECLARE VARIABLE VAR_UNIQO INTEGER = 0;
DECLARE VARIABLE VAR_UNIQL INTEGER = 0;
begin
   select prev_locations
   from locations
   where UNIQL = :VI_UNIQL
   into :VAR_UNIQL;
    /*
   select uniqo
   from orders
   where KEY_LOCATIONS = :VAR_UNIQL
   and ord_state = 0
   into :VAR_UNIQO;
  */
   if (:VAR_UNIQL <> 0) then begin
        update orders
        set ord_state=9, time_stop=(select current_timestamp from RDB$DATABASE), key_smn_stop = :VI_SMENA
        where key_locations = :VI_UNIQL and ord_state = 0;

        update locations
        set loc_state=9, time_stop=(select current_timestamp from RDB$DATABASE), key_smn_stop = :VI_SMENA
        where UNIQL = :VI_UNIQL and loc_state = 0;

        update locations
        set loc_state=0
        where UNIQL = :VAR_UNIQL  and loc_state = 1;

        end
/*
   if (:VAR_UNIQO <> 0) then begin
      update orders
      set ord_state = 0
      where uniqo = :VAR_UNIQO and ord_state = 1;
      end
*/
    suspend;
end^


ALTER PROCEDURE LOCATION_START (
    VI_THEME SMALLINT,
    VI_LOCATION SMALLINT,
    VI_LOC_TYPE SMALLINT,
    VI_THM_RESSORT SMALLINT,
    VI_SMN_START INTEGER,
    VI_PREV_LOCATIONS INTEGER)
RETURNS (
    VO_UNIQL INTEGER)
AS
   declare tmp_location_type smallint;
   declare tmp_freq smallint;
begin
-- вот здесь производить проверку на задолжность и если есть - бросать в аренду
-- или в долг, в зависимости смотр€ кака€ задолжность - короче, просто мен€ть   KEY_LOC_TYPE,   KEY_LOCATION,
    VO_UNIQL = 0;
-- ищем младший активный хвост
    select min(uniql)
    from locations
    where loc_state = 4
        and key_theme = :vi_theme
        and key_location = :vi_location
        and :vi_loc_type <> 3
    into :vo_uniql;
-- рубим хвосты
    select s_location_type from s_location where s_location.cod_location = :vi_location into :tmp_location_type;

    update
        locations
    set
        locations.loc_state = 5
    where
            loc_state = 4
        and key_theme = :vi_theme
        and (
            :vi_loc_type in (0,2,4,6,8,10)
            or
            key_location = :vi_location
            or
            key_location in (select cod_location from s_location where s_location.s_location_type = :tmp_location_type)
            )
        and :vi_loc_type <> 3;
-- если хвост был - ставим на его место, иначе - новый
    
    select thm_freq from s_theme where cod_theme = :vi_theme into :tmp_freq;
    if (tmp_freq = 9) then vi_thm_ressort = 9;

    if(vo_uniql > 0) then begin
        update locations
            set
                        KEY_LOC_TYPE=:vi_loc_type,
                        THM_RESSORT=:VI_THM_RESSORT,
                        KEY_SMN_START=:VI_SMN_START,
                        PREV_LOCATIONS=:VI_PREV_LOCATIONS,
                        LOC_STATE=0,
                        TIME_START=(select current_timestamp from RDB$DATABASE)
            where uniql=:vo_uniql;
        end
    else begin
        VO_UNIQL = gen_id(gen_uniql,1);
        insert into locations (uniql,
                        KEY_THEME,
                        KEY_LOCATION,
                        KEY_LOC_TYPE,
                        THM_RESSORT,
                        KEY_SMN_START,
                        PREV_LOCATIONS,
                        LOC_STATE,
                        TIME_START)
                 values (:VO_UNIQL,
                        :vi_theme,
                        :vi_location,
                        :vi_loc_type,
                        :VI_THM_RESSORT,
                        :VI_SMN_START,
                        :VI_PREV_LOCATIONS,
                        0,
                        (select current_timestamp from RDB$DATABASE));
        end

    suspend;
end^


ALTER PROCEDURE LOCATION_STOP (
    VI_UNIQL INTEGER,
    VI_SMN_STOP INTEGER)
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
declare variable tmp integer;
begin
    select count (l1.uniql)
    from locations l1
    where l1.uniql = :VI_UNIQL
    and l1.loc_state = 0
    into :VO_STOP_COUNT;

    if (VO_STOP_COUNT>0) then begin

            update locations
            set loc_state = 1,
                KEY_smn_STOP = :VI_smn_STOP,
                TIME_STOP = (select current_timestamp from RDB$DATABASE)
            where uniql = :VI_UNIQL;
        end
    else vo_stop_count = 0;
  suspend;
end^


ALTER PROCEDURE LOCATION_UNMARK (
    VI_THEME INTEGER)
AS
begin
    update locations set loc_state = 1 where key_theme = :vi_theme and loc_state=4;

  suspend;
end^


ALTER PROCEDURE LOCATION_UPDATE (
    VI_UNIQL INTEGER,
    VI_THM_RESSORT SMALLINT,
    VI_LOC_TYPE SMALLINT)
RETURNS (
    VO_UPDATE_COUNT SMALLINT)
AS
begin
    select count (l1.uniql)
    from locations l1
    where l1.uniql = :VI_UNIQL
    and l1.loc_state = 0
    into :VO_UPDATE_COUNT;
--возможно, вставить сюда дополнительную запись псевдо локации?
    if (:VO_UPDATE_COUNT<>0) then
        update locations l2
        set l2.KEY_LOC_TYPE = :VI_LOC_TYPE,
            l2.thm_ressort = :VI_THM_RESSORT,
            l2.time_start = (select current_timestamp from RDB$DATABASE)
        where l2.uniql = :VI_UNIQL;

  suspend;
end^


ALTER PROCEDURE ORDER_DELETE (
    VI_UNIQO INTEGER,
    VI_SMN_STOP INTEGER)
AS
begin
  update orders
  set TIME_STOP=(select current_timestamp from RDB$DATABASE),
       ord_state=8, key_smn_stop = :VI_SMN_STOP
  where
    uniqo=:VI_UNIQO;

  suspend;
end^


ALTER PROCEDURE ORDER_START (
    VI_THEME SMALLINT,
    VI_LOCATIONS INTEGER,
    VI_TYPE SMALLINT,
    VI_SMN_START INTEGER,
    VI_DEPARTURE VARCHAR(250),
    VI_DESTINATION VARCHAR(250),
    VI_STATE SMALLINT,
    VI_TIME_START TIMESTAMP,
    VI_COST DOUBLE PRECISION,
    VI_PHONE VARCHAR(64),
    VI_CLIENT INTEGER)
AS
DECLARE VARIABLE VAR_WEEKEND SMALLINT;
DECLARE VARIABLE VAR_ACTION SMALLINT;
begin

    select smn_weekend, smn_action
    from smena
    where uniqs = :VI_SMN_START
    into :VAR_WEEKEND, :var_action;

    -- 23 номер - код приема аренды!
    if (vi_type = 23) then begin
        update vehicles set account = account + :vi_cost where key_theme = :vi_theme;
        --после этого проверить, стоит ли позывной в аренде (или штрафе) и если позвол€ет акаунт - вывести его в гараж.

        end
    if (var_action = 1 and vi_type in (7,6,5,8,1)) then vi_type = 0;

    if (not ((VAR_WEEKEND = 0 and VI_TYPE = 9) or VI_SMN_START=0) ) then begin
        if (VI_TIME_START is null) then
            insert into orders (uniqo, KEY_THEME, KEY_LOCATIONS, KEY_ORD_TYPE, ORD_DEPARTURE, ORD_DESTINATION, KEY_smn_start, ORD_state, ORD_COST, TIME_START, ORD_PHONE,  key_client)
            values (gen_id(gen_uniqo,1), :vi_theme, :VI_LOCATIONS, :vi_type, :VI_DEPARTURE, :VI_DESTINATION, :vi_smn_start, :vi_state, :VI_COST, (select current_timestamp from RDB$DATABASE), :VI_PHONE, :vi_client );
        else
            insert into orders (uniqo, KEY_THEME, KEY_LOCATIONS, KEY_ORD_TYPE, ORD_DEPARTURE, ORD_DESTINATION, KEY_smn_start, ORD_state, ORD_COST, TIME_START, ORD_PHONE, key_client)
            values (gen_id(gen_uniqo,1), :vi_theme, :VI_LOCATIONS, :vi_type, :VI_DEPARTURE, :VI_DESTINATION, :vi_smn_start, :vi_state, :VI_COST, :VI_TIME_START, :VI_PHONE, :vi_client);
        end

  suspend;
end^


ALTER PROCEDURE ORDER_STOP (
    VI_SMN_STOP INTEGER,
    VI_TIME_STOP TIMESTAMP,
    VI_KEY_LOCATIONS INTEGER)
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
declare variable cost double precision;
declare variable tmp integer;
begin
    VO_STOP_COUNT =0 ;

    select ord_cost, key_ord_type
    from orders
    where key_locations = :VI_KEY_LOCATIONS and ord_state = 0
    into :cost, :tmp 
    ;

   if ( tmp in (2,3,4,19,6) and cost is null ) then begin
        VO_STOP_COUNT=-1;
        suspend;
        exit;
        end

    select count (o1.uniqo)
    from orders o1
    where o1.key_locations = :VI_KEY_LOCATIONS
    and o1.ord_state = 0
    into :VO_STOP_COUNT;

    if (:VI_TIME_STOP is null and :VO_STOP_COUNT<>0) then
            update orders o2
            set o2.ord_state = 1,
                o2.key_smn_stop = :VI_SMN_STOP,
                o2.time_stop=(select current_timestamp from RDB$DATABASE)
            where o2.key_locations = :VI_KEY_LOCATIONS and o2.ord_state = 0;

    else if(:VI_TIME_STOP is not null and :VO_STOP_COUNT<>0) then
            update orders o3
            set o3.ord_state = 1,
                o3.key_smn_stop = :VI_SMN_STOP,
                o3.time_stop=:VI_TIME_STOP
            where o3.key_locations = :VI_KEY_LOCATIONS and o3.ord_state = 0;

  suspend;
end^


ALTER PROCEDURE ORDER_UPDATE (
    VI_UNIQO INTEGER,
    VI_ORD_TYPE SMALLINT,
    VI_STATE SMALLINT,
    VI_DURATION TIME,
    VI_DISTANCE INTEGER,
    VI_COST DOUBLE PRECISION,
    VI_DEPARTURE VARCHAR(250),
    VI_DESTINATION VARCHAR(250),
    VI_TIME_START TIMESTAMP,
    VI_TIME_STOP TIMESTAMP,
    VI_SMN_STOP INTEGER,
    VI_CLIENT INTEGER,
    VI_PHONE VARCHAR(64))
RETURNS (
    VO_STOP_COUNT SMALLINT)
AS
declare variable tmp integer;
declare variable cost double precision;
begin

    if (vi_state = 1) then begin 
        select ord_cost, key_ord_type
        from orders
        where uniqo = :VI_UNIQO and ord_state = 0
        into :cost, :tmp
        ;
    
       if ( tmp in (2,3,4,19) and cost is null ) then begin
            VO_STOP_COUNT=-1;
            suspend;
            exit;
            end

        end

  update orders set KEY_ORD_TYPE=:VI_ORD_TYPE, TIME_STOP=(select current_timestamp from RDB$DATABASE),
       ord_state=:VI_STATE, ord_duration=:VI_DURATION, ord_distance=:VI_DISTANCE, ORD_COST=:VI_COST,
       ord_departure = :VI_DEPARTURE, ord_destination = :VI_DESTINATION,
       key_smn_stop = :VI_SMN_STOP, key_client = :vi_client , ord_phone=:vi_phone
  where
    uniqo=:VI_UNIQO;
  suspend;
end^


ALTER PROCEDURE REPORT_CREATE (
    VI_DATE_START DATE,
    VI_DATE_STOP DATE)
AS
DECLARE VARIABLE VAR_PREV_WEEK INTEGER;
DECLARE VARIABLE VAR_ORD_ITOG NUMERIC(8,2);
DECLARE VARIABLE VAR_REP_DOLG NUMERIC(8,2);
DECLARE VARIABLE VAR_THEME SMALLINT;
DECLARE VARIABLE VAR_UNIQW INTEGER;
DECLARE VARIABLE VAR_STATE SMALLINT;
begin
    select uniqw,wks_state -- выберем данные предыдущего отчета
    from weeks
    where date_stop = :vi_date_start - 1
        and wks_state <> 2
        and wks_state is not null
    into :var_prev_week,:var_state;

    if (var_prev_week is null) then var_prev_week = 0; -- если предыдущего нет - ссылка на него будет = 0
    else if (var_state = 0) then update weeks set wks_state = 1 where uniqw = :var_prev_week; -- на вс€кий случай закроем открытый

    select uniqw from weeks  -- на вс€кий случай проверим, вдруг такой уже существует
    where date_start = :vi_date_start
        and date_stop = :vi_date_stop
        and wks_state <> 2
        and wks_state is not null
    into :var_uniqw;

    if (var_uniqw is not null and var_uniqw <> 0) then begin -- если существует
       if (var_prev_week is not null and var_prev_week <> 0) then
          update weeks set key_prev_week = :var_prev_week where uniqw = :var_uniqw;
       delete from reports where key_week = :var_uniqw;
       end
    else begin
       var_uniqw = gen_id(gen_uniqw, 1);
       insert into weeks (uniqw, date_start, date_stop, key_prev_week)
       values (:var_uniqw, :vi_date_start, :vi_date_stop, :var_prev_week);
       end

    for select cod_theme from s_theme where cod_theme <> 0 order by cod_theme
    into :var_theme do begin

       var_ord_itog = null;
       var_rep_dolg = null;

       if (var_prev_week is not null and var_prev_week <> 0) then
          select rep_ostatok from reports where key_week = :var_prev_week and key_theme = :var_theme
          into :var_rep_dolg;

       if (var_ord_itog = 0) then var_ord_itog = null;
       if (var_rep_dolg = 0) then var_rep_dolg = null;

       insert into reports(uniqr, key_theme, key_week, rep_orders, rep_dolg)
       values(gen_id(gen_uniqr, 1), :var_theme, :var_uniqw, :var_ord_itog, :var_rep_dolg);

       end

   suspend;
end^


ALTER PROCEDURE REPORT_ITOG (
    VI_WEEK INTEGER)
AS
DECLARE VARIABLE VAR_UNIQR INTEGER;
DECLARE VARIABLE VAR_ORDERS DOUBLE PRECISION;
DECLARE VARIABLE VAR_REKLAMA DOUBLE PRECISION;
DECLARE VARIABLE VAR_CORRECT DOUBLE PRECISION;
DECLARE VARIABLE VAR_MEDIK DOUBLE PRECISION;
DECLARE VARIABLE VAR_DOLG DOUBLE PRECISION;
DECLARE VARIABLE VAR_KWART DOUBLE PRECISION;
DECLARE VARIABLE VAR_ITOG DOUBLE PRECISION;
DECLARE VARIABLE VAR_OT4ET DOUBLE PRECISION;
DECLARE VARIABLE VAR_TMP_SUM NUMERIC(8,2);
begin

   for select uniqr, rep_orders, rep_reklama, rep_medik, rep_dolg, rep_kwart, rep_correct, rep_itog, rep_ot4et
   from reports where key_week = : vi_week
   into :var_uniqr, :var_orders, :var_reklama, :var_medik, :var_dolg, :var_kwart, :var_correct, :var_itog, :var_ot4et
   do begin
      var_tmp_sum=cast(0 as double precision);

      if (var_orders is not null) then
         var_tmp_sum = var_tmp_sum + var_orders;

      if (var_reklama is not null) then
         var_tmp_sum = var_tmp_sum + var_reklama;

      if (var_medik is not null) then
         var_tmp_sum = var_tmp_sum + var_medik;

      if (var_dolg is not null) then
         var_tmp_sum = var_tmp_sum + var_dolg;

      if (var_kwart is not null) then
         var_tmp_sum = var_tmp_sum + var_kwart;

      if (var_correct is not null) then
         var_tmp_sum = var_tmp_sum + var_kwart;

      if (var_tmp_sum <> 0) then
         var_itog = var_tmp_sum;
      else
         var_itog = null;

      if (var_ot4et is not null) then
         var_tmp_sum = var_tmp_sum - var_ot4et;

      if (var_tmp_sum = 0) then
         var_tmp_sum = null;

      update reports
      set rep_itog = :var_itog, rep_ostatok = :var_tmp_sum
      where uniqr = :var_uniqr;

      end
   suspend;
end^


ALTER PROCEDURE REPORT_RECALC (
    VI_WEEK INTEGER)
AS
declare variable var_prev_week integer;
declare variable var_ord_itog numeric(8,2);
declare variable var_adm_itog numeric(8,2);
declare variable var_rep_dolg numeric(8,2);
declare variable var_theme smallint;
declare variable var_uniqr integer;
declare variable var_uniqw integer;
declare variable var_date_start date;
declare variable var_date_stop date;
declare variable var_brigade varchar(1) character set win1251;
begin
    select date_start, date_stop from weeks where uniqw=:vi_week
    into :var_date_start, :var_date_stop;

    select uniqw from weeks where date_stop = :var_date_start - 1 and wks_state <>2 and wks_state is not null
    into :var_prev_week;
    if (var_prev_week is null) then var_prev_week = 0;

    if (var_prev_week is not null and var_prev_week <> 0) then
       update weeks set key_prev_week = :var_prev_week where uniqw = :vi_week;

/*$$IBEC$$    for select uniqs from smena where smn_date >= 
:var_date_start and smn_date <= :var_date_stop
    into :var_uniqs
    do execute procedure itog(var_uniqs); $$IBEC$$*/

    for select cod_theme,thm_brigade from s_theme where cod_theme > 0 order by cod_theme
    into :var_theme,:var_brigade do begin

       var_ord_itog=null;
       var_rep_dolg=null;

       select sum(ord_itog),sum(adm_itog) from orders, smena
       where smn_date >= :var_date_start and smn_date <= :var_date_stop
       and uniqs = key_smn_start
       and key_theme = :var_theme
       and ord_state in (1,3)
       into :var_ord_itog, :var_adm_itog;

-- "временна€"  мера, чтобы заставить работать лент€ев
    if(var_adm_itog<70 and var_brigade is null) then begin
        select sum(ord_itog) from orders, smena
        where smn_date >= :var_date_start and smn_date <= :var_date_stop
        and uniqs = key_smn_start
        and key_theme = :var_theme
        and ord_state in(1,3) and ord_itog<0 -- считаем сколько ему должны вернуть
        into :var_ord_itog;
        if (var_ord_itog is null) then var_ord_itog=0;
        var_ord_itog=var_ord_itog+70; -- к этому-прибавим полтинник
        end

       if (var_prev_week is not null and var_prev_week <> 0) then
          select rep_ostatok from reports where key_week = :var_prev_week and key_theme = :var_theme
          into :var_rep_dolg;

       select uniqr from reports
       where key_theme = :var_theme and key_week = :vi_week
       into :var_uniqr;

       if (var_ord_itog = 0) then var_ord_itog = null;
       if (var_rep_dolg = 0) then var_rep_dolg = null;

       if (var_uniqr <> 0 and var_uniqr is not null) then
          update reports
          set rep_orders = :var_ord_itog, rep_dolg = :var_rep_dolg
          where uniqr = :var_uniqr;
       else
          insert into reports(uniqr, key_theme, key_week, rep_orders,rep_dolg)
          values(gen_id(gen_uniqr, 1), :var_theme, :var_uniqw, :var_ord_itog, :var_rep_dolg);
       end


--  execute procedure report_itog(var_uniqw);
   suspend;
end^


ALTER PROCEDURE REPORT_THM_INFO (
    VI_WEEK INTEGER)
AS
declare variable var_theme smallint;
declare variable var_ostatok numeric(8,2);
declare variable var_info varchar(32);
begin
    for select cod_theme from s_theme
    into :var_theme do begin

        select rep_ostatok from reports
        where key_week = :vi_week and key_theme = :var_theme
        into :var_ostatok;

    

        var_info =
            cast (extract(year from current_timestamp) as varchar(4))
            ||'.'||
            cast (extract(month from current_timestamp) as varchar(2))
            ||'.'||
            cast (extract(day from current_timestamp) as varchar(2))
            ||' '||
            cast (extract(hour from current_timestamp) as varchar(2))
            ||':'||
            cast (extract(minute from current_timestamp) as varchar(2))
            ||' долг '||
            cast(var_ostatok as varchar(11));

        if(var_ostatok > 0.0) then begin
            update s_theme
            set thm_info = :var_info
            where cod_theme = :var_theme;
            end
        else begin
            update s_theme
            set thm_info = null
            where cod_theme = :var_theme;
            end
            

        end

  suspend;
end^


ALTER PROCEDURE REPORT_UPDATE (
    VI_WEEK INTEGER)
AS
DECLARE VARIABLE VAR_PREV_WEEK INTEGER;
DECLARE VARIABLE VAR_ORD_ITOG DOUBLE PRECISION;
DECLARE VARIABLE VAR_REP_DOLG DOUBLE PRECISION;
DECLARE VARIABLE VAR_THEME SMALLINT;
DECLARE VARIABLE VAR_UNIQW INTEGER;
DECLARE VARIABLE VAR_UNIQR INTEGER;
DECLARE VARIABLE VAR_DATE_START DATE;
DECLARE VARIABLE VAR_DATE_STOP DATE;
begin

    select uniqw, date_start, date_stop, key_prev_week from weeks 
where uniqw = :vi_week
    into :var_uniqw, :var_date_start, :var_date_stop, :var_prev_week;

    if (var_uniqw is not null and var_uniqw <> 0) then begin

       for select uniqr, key_theme from reports where key_week = :vi_week
       into :var_uniqr, :var_theme do begin

          var_ord_itog = null;
          var_rep_dolg = null;

          select sum(ord_itog) from orders, smena
          where smn_date >= :var_date_start and smn_date <= :var_date_stop
          and key_theme = :var_theme and key_smn_start = uniqs
          and ord_state in (1, 3)
          into :var_ord_itog;

          if (var_prev_week is not null and var_prev_week <> 0) then
             select rep_ostatok from reports where key_week = :var_prev_week and key_theme = :var_theme
             into :var_rep_dolg;

         if (var_ord_itog = 0) then var_ord_itog = null;
         if (var_rep_dolg = 0) then var_rep_dolg = null;

          update reports
             set rep_orders = :var_ord_itog, rep_dolg = :var_rep_dolg
             where uniqr = :var_uniqr;
          end

       end

    suspend;
end^


ALTER PROCEDURE RESSORT_DAY
RETURNS (
    VO_RESSORT INTEGER)
AS
begin
select count (uniql)
from locations
where loc_state = 0
and THM_RESSORT in (1,3,4,6,7,8,9)
into :VO_RESSORT;

UPDATE LOCATIONS 
SET THM_RESSORT=5
WHERE loc_state = 0
and THM_RESSORT in (4,6,7,8,9);

UPDATE LOCATIONS 
SET THM_RESSORT=2
WHERE loc_state = 0
and THM_RESSORT in (1,3);

suspend;
end^


ALTER PROCEDURE RESSORT_NIGHT
RETURNS (
    VO_RESSORT INTEGER)
AS
begin
select count (uniql)
from locations
where loc_state = 0
and THM_RESSORT in (1,4,7)
into :VO_RESSORT;

UPDATE LOCATIONS SET THM_RESSORT=3 WHERE loc_state = 0 and THM_RESSORT = 2;
UPDATE LOCATIONS SET THM_RESSORT=6 WHERE loc_state = 0 and THM_RESSORT = 5;
UPDATE LOCATIONS SET THM_RESSORT=9 WHERE loc_state = 0 and THM_RESSORT = 8;

UPDATE LOCATIONS SET THM_RESSORT=2 WHERE loc_state = 0 and THM_RESSORT = 1;
UPDATE LOCATIONS SET THM_RESSORT=5 WHERE loc_state = 0 and THM_RESSORT = 4;
UPDATE LOCATIONS SET THM_RESSORT=8 WHERE loc_state = 0 and THM_RESSORT = 7;

suspend;
end^


ALTER PROCEDURE SMENA_ACTION (
    VI_UNIQS INTEGER,
    VI_SMN_ACTION SMALLINT)
AS
begin

    update smena
    set smn_action = :VI_SMN_action
    where uniqs=:VI_UNIQS;

    suspend;
end^


ALTER PROCEDURE SMENA_CHECK (
    VI_UNIQS INTEGER)
RETURNS (
    VO_SMN_STATE SMALLINT,
    VO_SMN_WEEKEND SMALLINT,
    VO_SMN_ACTION SMALLINT)
AS
begin

  select smn_state
  from smena
  where uniqs=:VI_UNIQS
  into :VO_SMN_STATE;

  select smn_weekend
  from smena
  where uniqs=:VI_UNIQS
  into :VO_SMN_WEEKEND;

  select smn_action
  from smena
  where uniqs=:VI_UNIQS
  into :VO_SMN_action;

  suspend;
end^


ALTER PROCEDURE SMENA_ITOG (
    VI_UNIQS INTEGER)
AS
DECLARE VARIABLE HOURS DOUBLE PRECISION;
DECLARE VARIABLE UNIQO INTEGER;
DECLARE VARIABLE ORD_DURATION TIME;
DECLARE VARIABLE ORD_DISTANCE INTEGER;
DECLARE VARIABLE ORD_COST NUMERIC(8,2);
DECLARE VARIABLE TIME_START TIMESTAMP;
DECLARE VARIABLE TIME_STOP TIMESTAMP;
DECLARE VARIABLE COD_ORD_TYPE SMALLINT;
DECLARE VARIABLE ORD_ITOG NUMERIC(8,2);
DECLARE VARIABLE COST_ORDER NUMERIC(8,2);
DECLARE VARIABLE COST_HNEXT NUMERIC(8,2);
DECLARE VARIABLE COST_DURATION NUMERIC(8,2);
DECLARE VARIABLE COST_DISTANCE NUMERIC(8,2);
DECLARE VARIABLE COST_MUX NUMERIC(8,2);
DECLARE VARIABLE TMP_COUNTER INTEGER;
begin
   for select so.cost_order, so.cost_duration, so.cost_distance, so.cost_hnext, so.cost_mux, so.cod_ord_type
   from s_ord_type so
   into :COST_ORDER, :COST_DURATION, :COST_DISTANCE, :COST_HNEXT, :COST_MUX, :COD_ORD_TYPE
   do begin
-----------------------------------------------------------------------------------------------
      for select UNIQO, ORD_COST, ORD_DISTANCE, ORD_DURATION, TIME_START, TIME_STOP
      from orders
      where key_smn_start = :VI_UNIQS
      and key_ord_type = :cod_ord_type
      and ord_state in (1, 3)
      into :UNIQO, :ORD_COST, :ORD_DISTANCE, :ORD_DURATION, :TIME_START, :TIME_STOP
      do begin
         ORD_ITOG = 0;

         if (COST_ORDER is not null) then
            ord_itog = ord_itog + cost_order;

         if (COST_MUX is not null and ORD_COST is not null) then
            ord_itog = ord_itog + cost_mux*ord_cost;
/*$$IBEC$$          else begin
            if (COST_DURATION is not null and ORD_DURATION is not null) then
               ord_itog = ord_itog + cost_duration*(cast(ord_duration as double precision)/0.000694);
            if (COST_distance is not null and ORD_distance is not null) then
               ord_itog = ord_itog + cost_distance*ord_distance;
            end $$IBEC$$*/

         if (COST_HNEXT is not null and time_stop is not null and time_start is not null) then begin
            if (cod_ord_type = 9) then
               hours=(cast ((time_stop-time_start) as double precision ))/cast (0.041667 as double precision);
            else
               hours=(cast ((time_stop-time_start)as double precision)-0.010417)/cast (0.041667 as double precision);
            TMP_COUNTER=0;
            while (hours>1) do begin
               tmp_counter=tmp_counter+1;
               hours=hours-1;
               end
            update orders set ord_hours = :TMP_COUNTER where uniqo = :uniqo;
            ord_itog = ord_itog + TMP_COUNTER * cost_hnext;
            end
------------------------------------------------------------------------------------------------
         update orders set ord_itog = :ORD_ITOG where uniqo = :UNIQO;
         end
------------------------------------------------------------------------------------------------
      end
   suspend;
end^


ALTER PROCEDURE SMENA_REPNO (
    VI_UNIQS INTEGER)
RETURNS (
    VO_ORDERS INTEGER,
    VO_HOURS INTEGER,
    VO_ORD_COST NUMERIC(8,2))
AS
begin
       select count(uniqo)
        from orders
        where key_smn_start = :vi_uniqs
        and ord_state in(1,3)
        and key_ord_type not in (0,15)
        into :vo_orders;

--vo_orders = 0; -- количество заказов держим в секрете :) 20090331

       select sum(ord_hours)
          from orders
          where key_smn_start = :vi_uniqs
          and ord_state in(1,3)
          and key_ord_type not in (0,15)
          into :VO_HOURS;

       select sum(ord_cost)
          from orders
          where key_smn_start = :vi_uniqs
          and ord_state in(1,3)
          and key_ord_type in (6,8,25)
          into :vo_ord_cost;

       suspend;
    --suspend;
end^


ALTER PROCEDURE SMENA_REPORT (
    START_DATE DATE,
    STOP_DATE DATE)
RETURNS (
    VO_UNIQS INTEGER,
    VO_USR_LIST VARCHAR(250),
    VO_SMN_DATE DATE,
    VO_DAY_NIGHT VARCHAR(5),
    VO_ORDERS INTEGER,
    VO_ORD_COST NUMERIC(8,2))
AS
declare variable var_day_night smallint;
declare variable var_hours integer;
begin
    for select uniqs, smn_date, smn_day_night, usr_list
    from smena
    where smn_date >= :start_date and smn_date <= :stop_date
    order by uniqs
    into :vo_uniqs,:vo_smn_date,:var_day_night, :vo_usr_list

    do begin
       if (var_day_night = 0) then vo_day_night = 'день';
       else vo_day_night = 'ночь';

       select count(uniqo)
        from orders
        where key_smn_start = :vo_uniqs
        and ord_state in(1,3)
        and key_ord_type not in (0,15)
        into :vo_orders;

--vo_orders = 0; -- количество заказов держим в секрете :) 20090331

       select sum(ord_hours)
          from orders
          where key_smn_start = :vo_uniqs
          and ord_state in(1,3)
          and key_ord_type in (1,2,3,4,5,7,8,9,25)
          into :VAR_HOURS;
       if(VAR_HOURS is not null) then
           vo_orders = vo_orders + var_hours;

       select sum(ord_cost)
          from orders
          where key_smn_start = :vo_uniqs
          and ord_state in(1,3)
          and key_ord_type in (6,8,25)
          into :vo_ord_cost;

       suspend;
       end
    --suspend;
end^


ALTER PROCEDURE SMENA_START (
    VI_DAY_NIGHT SMALLINT,
    VI_DATE DATE,
    VI_USR_LIST VARCHAR(250))
RETURNS (
    VO_UNIQS INTEGER)
AS
declare variable var_uniqv integer;
declare variable var_uniqs integer;
declare variable var_uniql integer;
declare variable var_key_theme smallint;
declare variable var_account numeric(8,2);
declare variable var_rental numeric(8,2);
declare variable temp integer;
begin
    update smena
    set smn_state=4
    where smn_state=0;

    VAR_UNIQS=gen_id(gen_uniqs,1);
    VO_UNIQS=var_uniqs;
/*
    1.


    if (vi_day_night = 0) then
        for select uniqv, account, rental, key_theme
        from vehicles
        where uniqv <> 0
        into :var_uniqv, :var_account, :var_rental, :var_key_theme
        do begin
            if (var_rental is null) then var_rental = 0;
            if (var_account is null) then var_account = 0;
            if (var_account - var_rental >= 0) then begin-- если денег хватает на счету - пусть работает
                execute procedure pay_vehicle( var_uniqv, var_key_theme, 0, vi_date, vo_uniqs, var_rental); -- проводим оплату за этот день
                update vehicles -- cнимаем деньги со счета
                    set account = :var_account - :var_rental
                    where uniqv = :var_uniqv;
                end
            else begin-- иначе загон€ем злостного должника в аренду
                select uniql from locations where loc_state=0 and key_theme = :var_key_theme into :var_uniql;
                execute procedure PAY_VEHICLE ( var_uniqv, var_key_theme, 1, vi_date, vo_uniqs, 0); -- проводим по аренде как выходной
                execute procedure order_stop(var_uniqs, null , var_uniql) RETURNING_VALUES :temp;
                execute procedure location_stop(var_uniql, vo_uniqs) RETURNING_VALUES :temp;
                execute procedure location_start(var_key_theme,0,8,0,vo_uniqs,var_uniql) RETURNING_VALUES :temp;
                end
            end
*/
    insert into smena(uniqs, smn_time_start, smn_state, smn_weekend, smn_action, smn_date, smn_day_night, usr_list)
    values(:VO_UNIQS, (select current_timestamp from RDB$DATABASE), 0, 1, 0, :VI_DATE, :VI_DAY_NIGHT, :VI_USR_LIST);
    
    suspend;
end^


ALTER PROCEDURE SMENA_STOP (
    VI_UNIQS INTEGER)
AS
begin
  update smena
  set smn_state=1, smn_time_stop=(select current_timestamp from RDB$DATABASE)
  where uniqs=:VI_UNIQS and smn_state = 0;

  update smena
  set smn_state=2, smn_time_stop=(select current_timestamp from RDB$DATABASE)
  where smn_state = 0;

  suspend;
end^


ALTER PROCEDURE SMENA_WEEKEND (
    VI_UNIQS INTEGER,
    VI_SMN_WEEKEND SMALLINT)
AS
begin

/*$$IBEC$$   update smena
  set smn_weekend = :VI_SMN_WEEKEND
  where uniqs=:VI_UNIQS; $$IBEC$$*/

  suspend;
end^


ALTER PROCEDURE THEME_ARCHIVE (
    VI_THEME SMALLINT)
AS
DECLARE VARIABLE VI_COLOR VARCHAR(32);
DECLARE VARIABLE THM_MODEL VARCHAR(32);
DECLARE VARIABLE THM_NUMBER VARCHAR(32);
DECLARE VARIABLE THM_INFO VARCHAR(32);
DECLARE VARIABLE REP_DOLG NUMERIC(8,2);
begin
    select thm_model, thm_color, thm_number, thm_info, rep_dolg
    from s_theme, reports, weeks
    where
        reports.key_week = weeks.uniqw
    and weeks.wks_state = 0
    and reports.key_theme = s_theme.cod_theme
    and cod_theme = :vi_theme
    into :thm_model, :vi_color, :thm_number, :thm_info, :rep_dolg
    ;
    
    insert into themes
        (uniqt, key_theme, thm_model, thm_color, thm_number, thm_info, rep_dolg, time_start)
    values
        (gen_id(gen_uniqt, 1), :vi_theme, :thm_model, :vi_color, :thm_number, :thm_info, :rep_dolg, (select current_timestamp from RDB$DATABASE))
    ;
    
    suspend;
end^


ALTER PROCEDURE THEME_MARKER (
    VI_THEME SMALLINT,
    VI_MARKER VARCHAR(1))
AS
begin
  update s_theme
  set thm_marker=:vi_marker
  where cod_theme = :vi_theme;
  suspend;
end^


ALTER PROCEDURE UPDATE_DICOUNT
AS
declare variable addr varchar(64);
declare variable info varchar(64);
declare variable name varchar(64);
declare variable tmp_o integer;
declare variable tmp_2 integer;
declare variable tmp_1 integer;
declare variable discount integer;
declare variable m integer;
declare variable n integer;
declare variable tmp integer;
begin

for select uniqc
from clients
where clt_name is null
into :tmp
do begin
    
    update orders
    set key_client =0
    where key_client = :tmp
    and uniqo < 1177263;  --конец июH€ 2009

    end

delete from clients where clt_name is null;



/*20090630 процедура очистки клиентов, не пользующихс€ услугами 2 мес€ца*/
/*$$IBEC$$     for select cod_theme
    from s_theme
    where cod_theme>100   and  thm_model is null
    into :tmp_o
    do begin
            
            update orders set key_theme = 0 where key_theme = :tmp_o;
            delete from locations where key_theme = :tmp_o;
            update reports set key_theme = 0 where key_theme = :tmp_o;

        end

    delete from s_theme
    where cod_theme>100   and  thm_model is null; $$IBEC$$*/



/* 20090510 процедура стирает хал€вные поздки и 13 обычных к хал€ве *//*$$IBEC$$ 
    for select uniqc,clt_name,clt_info,clt_adress,c.clt_discount
    from clients c
    where c.clt_counter=14 -- and uniqc =7
    into :tmp_o, :name, :info, :addr, :discount
    do begin
        select count(uniqo)   -- выбираем сколько поездок обычных
        from orders o, s_ord_type t
        where o.key_client = :tmp_o
        and o.key_ord_type = t.cod_ord_type
        and o.ord_state in (1,3)
        and t.ord_type = 1
        --and o.key_smn_start < 1989
        into :tmp_1;

        select count(uniqo)   -- сколько поездок хал€внох
        from orders o, s_ord_type t
        where o.key_client = :tmp_o
        and o.key_ord_type = t.cod_ord_type
        and o.ord_state in (1,3)
        and t.ord_type = 2
        --and o.key_smn_start < 1989
        into :tmp_2;

        --update orders set key_client = 0 where key_client = :tmp_o; --and key_smn_start < 1989;

        tmp = tmp_1 - tmp_2*13; -- вычисл€ем, сколько поездок незадействовано
        --tmp_1 = tmp/13;
        --tmp_2 = tmp - tmp_1 * 13;

 $$IBEC$$*//*$$IBEC$$ 
        if (discount is null) then
            update clients set clt_discount = :tmp_1 where uniqc = :tmp_o;
        else
            update clients set clt_discount = :discount + :tmp_1 where uniqc = :tmp_o;

 $$IBEC$$*//*$$IBEC$$ 
        tmp = tmp_2*13;


        update orders o
        set o.key_client = 0
        where o.key_client = :tmp_o
        and o.ord_state in (1,3)
        and (select ord_type from s_ord_type where s_ord_type.cod_ord_type=o.key_ord_type) = 2; -- обнул€ет хал€вные поездки

        for select uniqo
            from orders o, s_ord_type t
            where o.key_client = :tmp_o
            and o.key_ord_type = t.cod_ord_type
            and o.ord_state in (1,3)
            and t.ord_type = 1 --стирает поездки, потраченные на хал€ву
            order by uniqo
        into :tmp_2
        do begin
            if (tmp<=0) then break;
            update orders set key_client = 0 where uniqo=:tmp_2;
            tmp=tmp-1;
            end


 $$IBEC$$*//*$$IBEC$$
        while (tmp>0) do begin

            insert into orders (uniqo, KEY_THEME, KEY_LOCATIONS, KEY_ORD_TYPE, ORD_DEPARTURE, ORD_DESTINATION, KEY_smn_start, ORD_state, ORD_COST, TIME_START, ORD_PHONE,  key_client)
            values (gen_id(gen_uniqo,1), 0, 0, 1, '_ƒќѕќЋЌ≈Ќ»≈_', null, 1, 3, null, (select current_timestamp from RDB$DATABASE), null, :tmp_o );

            tmp=tmp-1;
            end
 $$IBEC$$*//*$$IBEC$$ 
        update clients set clt_counter = 13 where uniqc = :tmp_o;
        --suspend;
        end $$IBEC$$*/

--suspend;
end^


ALTER PROCEDURE VEHICLE_ADD (
    VI_THEME SMALLINT,
    VI_MODEL VARCHAR(32),
    VI_NUMBER VARCHAR(32),
    VI_COST NUMERIC(8,2),
    VI_DURATION SMALLINT,
    VI_RENTAL NUMERIC(8,2),
    VI_INFO VARCHAR(256))
AS
DECLARE VARIABLE VAR_RATE DOUBLE PRECISION;
DECLARE VARIABLE VAR_TEMP INTEGER;
begin
    select rate from exchange where state = 0 into :var_rate;
    if (var_rate is null) then var_rate = 0;

    insert into vehicles (
        uniqv,
        key_theme,
        model,
        number,
        cost,
        currency,
        account,
        rental,
        duration,
        time_start,
        vhc_state,
        info
        )
    values(
        gen_id(gen_uniqv,1),
        :vi_theme,
        :vi_model,
        :vi_number,
        :vi_cost,
        :vi_cost * :var_rate,
        0,
        :vi_rental,
        :vi_duration,
        (select current_timestamp from RDB$DATABASE),
        0,
        :vi_info
        );

    suspend;
end^


ALTER PROCEDURE VEHICLE_PAY (
    VI_UNIQV INTEGER,
    VI_ARN_ACTION SMALLINT,
    VI_ARN_DATE DATE,
    VI_SMENA INTEGER,
    VI_MONEY NUMERIC(8,2),
    VI_INFO VARCHAR(252))
AS
DECLARE VARIABLE VAR_BALANCE NUMERIC(8,2);
DECLARE VARIABLE VAR_CURRENCY NUMERIC(8,2);
DECLARE VARIABLE VAR_RATE DOUBLE PRECISION;
DECLARE VARIABLE VAR_UNIQA INTEGER;
DECLARE VARIABLE VAR_UNIQE INTEGER;
DECLARE VARIABLE VAR_MONEY NUMERIC(8,2);
DECLARE VARIABLE VAR_ACCOUNT NUMERIC(8,2);
DECLARE VARIABLE VAR_RENTAL NUMERIC(8,2);
DECLARE VARIABLE VAR_THEME SMALLINT;
DECLARE VARIABLE VAR_STATE_ARENDA SMALLINT;
DECLARE VARIABLE VAR_MUX_BALANCE NUMERIC(8,2);
DECLARE VARIABLE VAR_MUX_ACCOUNT NUMERIC(8,2);
begin
--  берем коэффициент дл€ данного типа транзакции из справочника
    SELECT MUX_balance, mux_account, state_arenda
        FROM S_ARN_ACTION
        where cod_arn_action = :vi_arn_action
        into :var_MUX_balance, :var_mux_account, :var_state_arenda;

--  берем счет и позывной из машинок
    SELECT KEY_THEME, ACCOUNT, CURRENCY, RENTAL
        FROM VEHICLES
        where uniqv = :vi_uniqv
        into :var_theme,  :var_account, :VAR_CURRENCY, :VAR_RENTAL;
    if (var_account is null) then var_account = 0;
    if (var_currency is null) then var_currency = 0;
    if (var_rental is null) then var_rental = 0;

--  берем курс валюты
    select UNIQE, rate
        from EXCHANGE
        where state = 0
        into :VAR_UNIQE, :var_rate;

--  берем данные о предыдущей аренде, то-есть баланс
    SELECT UNIQA, BALANCE
        from arenda
        where key_uniqv = :vi_uniqv and arn_state = 0
        into :var_uniqa, :var_balance;
--  теперь, когда знаем все данные надо делать выбор алгоритм€ что делать.

-- начнем с начала аренды - дл€ начала аренды мы вместо баланса берем стоимость машины
    if (vi_arn_action = 1) then begin
        var_balance = var_currency;
        var_money = 0;
        end
    else if (vi_money is null ) then
        var_money = var_rental;
    else
        var_money = vi_money;

-- если бабла маловато дл€ оплаты аренды ...
    if( vi_smena > 0 and var_account < var_rental  and vi_arn_action = 3 ) then begin
        var_money = 0;
        vi_arn_action = 6;
    --  ќп€ть берем новые коэффициенты
        SELECT MUX_balance, mux_account, state_arenda
            FROM S_ARN_ACTION
            where cod_arn_action = 6
            into :var_MUX_balance, :var_mux_account, :var_state_arenda;
        end

    -- и окончательно пересчитываем балансы
    var_account = var_account + var_mux_account * var_money;
    var_balance = var_balance + var_mux_balance * var_money * var_rate;
      
        
--  все поделили/отн€ли теперь можно вносить изменени€ в базу
    update vehicles
        set account = :var_account
        where uniqv = :vi_uniqv;


    if ( var_state_arenda in(0,1) ) then begin
        update arenda
            set arn_state = 1,
            key_smn_stop = :vi_smena,
            time_stop=(select current_timestamp from RDB$DATABASE)
            where uniqa = :var_uniqa;

        end
    
-- теперь вставка новой записи, если надо
    if ( var_state_arenda in(0,3) ) then begin

        insert into arenda (
            uniqa,
            prev_uniqa,
            arn_state,
            key_uniqv,
            key_theme,
            key_smn_start,
            KEY_ARN_ACTION,
            time_start,
            arn_date, --дата аренды
            money, -- деньги в национальной валюте
            currency, -- в условных ебеницах
            key_EXCHANGE, -- код курсa обмена
            balance, -- остаток
            info
            )
        values (
            gen_id(gen_uniqa, 1),
            :var_uniqa,
            :var_state_arenda,
            :vi_uniqv,
            :var_theme,
            :vi_smena,
            :vi_arn_action,
            (select current_timestamp from RDB$DATABASE),
            :vi_arn_date,
            :var_money,
            :var_money * :var_rate,
            :var_uniqe,
            :var_balance, -- уже должен быть изменен
            :vi_info
            );
        end

 EXIT;
end^


ALTER PROCEDURE VEHICLE_ROLLBACK (
    VI_UNIQA INTEGER)
AS
DECLARE VARIABLE VAR_ARN_ACTION SMALLINT;
DECLARE VARIABLE VAR_UNIQV INTEGER;
DECLARE VARIABLE VAR_MUX_ACCOUNT DOUBLE PRECISION;
DECLARE VARIABLE VAR_MONEY NUMERIC(8,2);
DECLARE VARIABLE VAR_UNIQA INTEGER;
DECLARE VARIABLE VAR_PREV_UNIQA INTEGER;
begin
    
    select prev_uniqa, money, key_uniqv, key_arn_action
        from arenda
        where uniqa = :vi_uniqa
        into var_prev_uniqa, var_money, var_uniqv, var_arn_action;

    select mux_account
        from s_arn_action
        where cod_arn_action = :var_arn_action
        into var_mux_account;

    update arenda
        set arn_state = 2, time_stop=(select current_timestamp from RDB$DATABASE)
        where uniqa = :vi_uniqa;

    update arenda
        set arn_state = 0
        where uniqa = :var_prev_uniqa;

    update vehicles
        set account = account - :var_mux_account * :var_money
        where uniqv = :var_uniqv;

    suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE LOCATIONS
'Ћокации машин';

DESCRIBE TABLE ORDERS
'«аказы и штрафы';

DESCRIBE TABLE S_LOCATION
'Ћокации на карте';

DESCRIBE TABLE S_LOC_TYPE
'“ип локации';

DESCRIBE TABLE S_THEME
'ѕозывные и машины';

DESCRIBE TABLE S_USER
'ѕользователи Ѕƒ';

DESCRIBE TABLE THEMES
'ѕозывные и машины';

DESCRIBE TABLE WEEKS
'ќтчетные периоды';



/* Fields descriptions */

DESCRIBE FIELD MONEY TABLE ARENDA
'внесенные гроши';

DESCRIBE FIELD CURRENCY TABLE ARENDA
'внесенные, пересчитанные в уе';

DESCRIBE FIELD BALANCE TABLE ARENDA
'остаток в у.е.';

DESCRIBE FIELD INFO TABLE ARENDA
'»нформаци€ дл€ пользовани€ или дл€ содержани€(типа, какие запчасти поставил:)';

DESCRIBE FIELD CLT_TYPE TABLE CLIENTS
'0-фиктивный, не в справочнике
1-обычный, лишь дл€ ускоренного ввода
2-за счет фирмы
3-адм.до 5 км.
4-адм.пробег.';

DESCRIBE FIELD CLT_COUNTER TABLE CLIENTS
'поездки нахал€в4у';

DESCRIBE FIELD UNIQL TABLE LOCATIONS
'”никальный ключ';

DESCRIBE FIELD PREV_LOCATIONS TABLE LOCATIONS
'—сылка на предыдущую локацию - дл€ отмены и анализа';

DESCRIBE FIELD LOC_STATE TABLE LOCATIONS
'0-активна/1-заверш/2-аварийно/9-rollback';

DESCRIBE FIELD KEY_THEME TABLE LOCATIONS
' люч на позывной';

DESCRIBE FIELD KEY_LOCATION TABLE LOCATIONS
' люч на локацию (по району)';

DESCRIBE FIELD KEY_LOC_TYPE TABLE LOCATIONS
'“ип локации на карте (гараж, на линии, ремонт, по заказу, долг, штраф i wse ostaljnoe)';

DESCRIBE FIELD THM_RESSORT TABLE LOCATIONS
'ѕозици€ в очереди 
0-фиктивный 
1-первоочередной в ночь
2-первоочередной обычный
3-первоочередной резервный 
4-в ночь
5-обычный
6-резервный 
7-второстепенный в ночь
8-второстепенный обычный
9-второстепенный резервный';

DESCRIBE FIELD TIME_START TABLE LOCATIONS
'начало локации';

DESCRIBE FIELD TIME_STOP TABLE LOCATIONS
'конец локации';

DESCRIBE FIELD UNIQO TABLE ORDERS
'”никальный ключ ордера/штрафа';

DESCRIBE FIELD KEY_THEME TABLE ORDERS
'ключ позывного';

DESCRIBE FIELD KEY_LOCATIONS TABLE ORDERS
' люч на реальную локацию';

DESCRIBE FIELD KEY_ORD_TYPE TABLE ORDERS
'тип ордера';

DESCRIBE FIELD ORD_STATE TABLE ORDERS
'состо€ние заказа:
0-активен
1-завершен
2-фиктивный дл€ учета отказов
3-разова€ форма
4-отложен в список
5-удален из списка
6-предварительный
7-удален с предварительных
8 - delete
9-rollback';

DESCRIBE FIELD ORD_DURATION TABLE ORDERS
'ƒлительность поездки';

DESCRIBE FIELD ORD_DISTANCE TABLE ORDERS
'прот€женность заказа в км';

DESCRIBE FIELD ORD_COST TABLE ORDERS
'стоимость заказа,предъ€вл€емого водителем в гривнах!';

DESCRIBE FIELD ORD_HOURS TABLE ORDERS
'количество почасовок';

DESCRIBE FIELD ORD_ITOG TABLE ORDERS
'»тогова€ сумма, отдаваема€ водителем в казну - —читаетс€ компутером ITOG';

DESCRIBE FIELD ORD_DESTINATION TABLE ORDERS
'куда и телефон';

DESCRIBE FIELD ORD_DEPARTURE TABLE ORDERS
'откуда и сколько';

DESCRIBE FIELD ORD_PHONE TABLE ORDERS
'телефон';

DESCRIBE FIELD ADM_ITOG TABLE ORDERS
'¬ременное(?) поле дл€ подсчета прибыли администрации';

DESCRIBE FIELD UNIQR TABLE REPORTS
'уникальный код ';

DESCRIBE FIELD KEY_THEME TABLE REPORTS
'код позывного';

DESCRIBE FIELD KEY_WEEK TABLE REPORTS
'ключ недели';

DESCRIBE FIELD REP_ORDERS TABLE REPORTS
'сумма по отработанным заказам';

DESCRIBE FIELD REP_REKLAMA TABLE REPORTS
'отчислени€ на рекламу';

DESCRIBE FIELD REP_MEDIK TABLE REPORTS
'прохождени€ медика';

DESCRIBE FIELD REP_DOLG TABLE REPORTS
'долги с предыдущей недели';

DESCRIBE FIELD REP_KWART TABLE REPORTS
'квартальные сборы';

DESCRIBE FIELD REP_ITOG TABLE REPORTS
'итого к оплате';

DESCRIBE FIELD REP_OT4ET TABLE REPORTS
'сумма взноса водителем в кассу';

DESCRIBE FIELD REP_OSTATOK TABLE REPORTS
'остаток денег, перенос€щихс€ в следующую неделю';

DESCRIBE FIELD REP_CORRECT TABLE REPORTS
' орректировка итога';

DESCRIBE FIELD SMN_STATE TABLE SMENA
'0-активна€ смена 
1-завершена смена 
2-аварийное завершение незакрытой
3-авар.подтверждение закрытой

';

DESCRIBE FIELD SMN_WEEKEND TABLE SMENA
'0-будни   1-праздник';

DESCRIBE FIELD USR_LIST TABLE SMENA
'список юзверей - дл€ справки';

DESCRIBE FIELD COD_ARN_ACTION TABLE S_ARN_ACTION
'€сень красен - ключ первичный';

DESCRIBE FIELD NAME_ARN_ACTION TABLE S_ARN_ACTION
'ѕросто наименование';

DESCRIBE FIELD STATE_ARENDA TABLE S_ARN_ACTION
'код дл€ аренды - состо€ние ';

DESCRIBE FIELD MUX_ACCOUNT TABLE S_ARN_ACTION
'коэффициент, дл€ пересчета счета';

DESCRIBE FIELD MUX_BALANCE TABLE S_ARN_ACTION
'дл€ баланса';

DESCRIBE FIELD COD_LOCATION TABLE S_LOCATION
' од/ключ локации';

DESCRIBE FIELD NAME_LOCATION TABLE S_LOCATION
'Ќаименование Ћокации';

DESCRIBE FIELD POS_TOP TABLE S_LOCATION
'ѕозици€ на форме Top';

DESCRIBE FIELD POS_LEFT TABLE S_LOCATION
'ѕозици€ но форме Left';

DESCRIBE FIELD COD_LOC_TYPE TABLE S_LOC_TYPE
'ключ типа локации';

DESCRIBE FIELD NAME_LOC_TYPE TABLE S_LOC_TYPE
'Ќаименование типа локации';

DESCRIBE FIELD ORD_TYPE TABLE S_ORD_TYPE
'что-то дл€ типа пол€ и где его примен€ть';

DESCRIBE FIELD COST_ORDER TABLE S_ORD_TYPE
'стоимость за разовый заказ';

DESCRIBE FIELD COST_HNEXT TABLE S_ORD_TYPE
'—умма за последующий час';

DESCRIBE FIELD COST_DURATION TABLE S_ORD_TYPE
'за минуту просто€';

DESCRIBE FIELD COST_DISTANCE TABLE S_ORD_TYPE
'за пробег 1 км';

DESCRIBE FIELD COST_MUX TABLE S_ORD_TYPE
' оэффициент от стоимости заказа ORD_COST';

DESCRIBE FIELD COD_THEME TABLE S_THEME
'ключ, он же позывной';

DESCRIBE FIELD THM_MODEL TABLE S_THEME
'ћарка машины';

DESCRIBE FIELD THM_COLOR TABLE S_THEME
'÷вет тарантайки';

DESCRIBE FIELD THM_NUMBER TABLE S_THEME
'√ос.номер';

DESCRIBE FIELD THM_INFO TABLE S_THEME
'»нформаци€';

DESCRIBE FIELD THM_FREQ TABLE S_THEME
'частота радиостанции на машине 0-не известно 1-нижн€€ 2-верхн€€';

DESCRIBE FIELD THM_BRIGADE TABLE S_THEME
'1 символ дл€ обозначени€ бригады';

DESCRIBE FIELD THM_PREFIX TABLE S_THEME
'префикс к є позывного';

DESCRIBE FIELD THM_SUFFIX TABLE S_THEME
'суффикс к є позывного';

DESCRIBE FIELD THM_TYPE TABLE S_THEME
'”ƒјЋ»“№';

DESCRIBE FIELD COD_USER TABLE S_USER
'главный ключ пользовател€';

DESCRIBE FIELD NAME_USER TABLE S_USER
'им€ пользовател€';

DESCRIBE FIELD UNIQT TABLE THEMES
'ключъ';

DESCRIBE FIELD THM_INFO TABLE THEMES
'»нформаци€';

DESCRIBE FIELD REP_DOLG TABLE THEMES
'ƒолг с последнего отчета';

DESCRIBE FIELD COST TABLE VEHICLES
'стоимость в uah';

DESCRIBE FIELD CURRENCY TABLE VEHICLES
'—тоимость в у.е.';

DESCRIBE FIELD ACCOUNT TABLE VEHICLES
'счет uah';

DESCRIBE FIELD DURATION TABLE VEHICLES
'ѕродолжительность аренды (дней)';

DESCRIBE FIELD RENTAL TABLE VEHICLES
'ежедневна€ плата uah';

DESCRIBE FIELD UNIQW TABLE WEEKS
'уникальный номер недели';

DESCRIBE FIELD DATE_START TABLE WEEKS
'дата начала недели';

DESCRIBE FIELD DATE_STOP TABLE WEEKS
'конечна€ дата';

DESCRIBE FIELD KEY_PREV_WEEK TABLE WEEKS
'предыдуща€ недел€';

